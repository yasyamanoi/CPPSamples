#pragma once

#include<iostream>
#include <sstream>
#include <exception>

using namespace std;

namespace cp {
	//--------------------------------------------------------------------------------------
	///	文字列型
	//--------------------------------------------------------------------------------------
	class String {
		char* m_pdata{ nullptr };
		size_t m_capacity{16};
		size_t m_size{};
		size_t m_maxsize{ UINT_MAX };
		void capacity_update(size_t n) {
			if (n >= (m_maxsize - 1)) {
				throw runtime_error("error: memory cannot be reserve.");
			}
			size_t cap = m_capacity;
			while (cap <= n) {
				cap *= 2;
			}
			auto pdata = new char[cap];
			if (m_pdata) {
				strcpy_s(pdata, cap - 1, m_pdata);
				delete[] m_pdata;
			}
			m_pdata = pdata;
			m_capacity = cap;
		}
	public:
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		*/
		//--------------------------------------------------------------------------------------
		String() {}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	コンストラクタ
		@param[in]	data	初期化する文字列
		*/
		//--------------------------------------------------------------------------------------
		String(const char* data) {
			size_t i = 0;
			while (data[i] != '\0') {
				if (i >= (m_maxsize - 1)) {
					throw runtime_error("error: memory cannot be secured.");
				}
				i++;
			}
			m_size = i;
			while (m_capacity < m_size) {
				m_capacity *= 2;
			}
			m_pdata = new char[m_capacity];
			strcpy_s(m_pdata, m_capacity - 1, data);
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	デストラクタ
		*/
		//--------------------------------------------------------------------------------------
		~String(){
			delete[] m_pdata;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	文字列の長さの取得
		@return	文字列の長さ
		*/
		//--------------------------------------------------------------------------------------
		size_t size() const{
			return m_size;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	文字列の長さの取得
		@return	文字列の長さ
		*/
		//--------------------------------------------------------------------------------------
		size_t length() const {
			return m_size;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	文字列の最大の長さの取得
		@return	文字列の最大の長さ
		*/
		//--------------------------------------------------------------------------------------
		size_t max_size() const {
			return m_maxsize;
		}
		//--------------------------------------------------------------------------------------
		/*!
		@brief	文字列の長さを変更する
		@return	なし
		*/
		//--------------------------------------------------------------------------------------
		void resize(size_t n){
			if (n < (m_capacity - 1)) {
				m_size = n;
			}
			else {
				capacity_update(n);
			}
		}

		//--------------------------------------------------------------------------------------
		/*!
		@brief	文字列の先頭のポインタの取得
		@return	文字列の先頭のポインタ
		*/
		//--------------------------------------------------------------------------------------
		const char* data() const {
			return m_pdata;
		}
	};
	//--------------------------------------------------------------------------------------
	/*!
	@brief	Stringをcoutで使えるようにする
	@param[in]	os	ostreamの参照
	@param[in]	s	Stringの参照
	@return	ostreamの参照
	*/
	//--------------------------------------------------------------------------------------
	inline ostream& operator <<(ostream& os, const String& s)
	{
		os << s.data();
		return os;
	};

}
//end namespace cp
